#Specify the functionality of the target archiecture

# Totoal 24 bytes
struct ip_header_t {
    # Version (4),  IHL (4), DSCP (6), ECN(2)
    bits<16> misc; 
    bits<16> length;
    bits<16> identification;
    # Flags (3), Fragment Offset (13)
    bits<16> fragment_offset;
    
    # TTL (8), Transport Protocol (8)
    bits<16> TTL_transport;
    bits<16> checksum;
    bits<32> source_ip;
    bits<32> dst_ip;
}

struct dma_desc_t {
  bits<16> queue_id;
  bits<16> meta;
}

extern event NET_RECV {context ctx; buf packet;}
extern event NET_SEND {context ctx; buf packet;}
extern handler NET_SEND:net_send (context ctx, buf packet) { }


##############main program########## #

struct eth_header_t {
  bits<48> dst_mac;
  bits<48> src_mac;
  bits<16> ether_type;
}

#Totoal 8 bytes
struct udp_header_t {
    bits<16> sport;                    
    bits<16> dport;                    

    bits<16> len;                      
    bits<16> sum;                      
}

struct rpc_header_t {
  bits<32> channel_id;
  bits<32> seq;
  bits<32> seg_size;
  bits<32> total_size;
}

event MSG_REASSEMBLE {
  context ctx;
  buf packet;
  rpc_header_t rpc;
}

controller MSG_REASSEMBLE() {
    In in1 = [NET_RECV:process_packet, 0];
    Out out1 = [MSG_REASSEMBLE:msg_reassemble, 0];

    # connects
    Queue(32)[in1][out1];
}

[instances=(i1cu2)] handler NET_RECV:process_packet(context ctx, buf packet) {
  eth_header_t eth_header;
  ip_header_t ip_header;
  udp_header_t udp_header;
  rpc_header_t rpc_header;

  packet.extract(eth_header);
  packet.extract(ip_header);
  packet.extract(udp_header);
  packet.extract(rpc_header);

  ctx.eth_header = eth_header;
  ctx.ip_header = ip_header;

  generate MSG_REASSEMBLE:msg_reassemble{ctx, packet, rpc_header};
}

struct agg_t {
  bits<32> rest_bytes;
  bits<32> next_seq;
}

[instances=(i1cu3)] handler MSG_REASSEMBLE:msg_reassemble(context ctx, buf data, rpc_header_t rpc_header) {
  table <bits<16>, agg_t, 16> reassemble_agg;
  table <bits<16>, buf, 16> reassemble_buf;

  agg_t old_agg;
  buf old_buf;
  # here do we init the buffer? check the generated code (for __buf_init)
  agg_t new_agg;

  old_agg = reassemble_agg.lookup(rpc_header.channel_id); 
  old_buf = reassemble_buf.lookup(rpc_header.channel_id); 

  if(old_agg.rest_bytes == 0){
    old_agg.rest_bytes = rpc_header.total_size;
    old_buf.emit(ctx.eth_header);
    old_buf.emit(ctx.ip_header);
  }

  #if(old_agg.next_seq + 1 == rpc_header.seq){
    old_agg.next_seq = old_agg.next_seq + 1;
    old_buf.emit(data);
    old_agg.rest_bytes = old_agg.rest_bytes - rpc_header.seg_size;
  #}

  if(old_agg.rest_bytes > 0){
    reassemble_agg.update(rpc_header.channel_id, old_agg);
    reassemble_buf.update(rpc_header.channel_id, old_buf);
  }
  else{
    buf new_buf;
    # assume aligned case
    new_agg.rest_bytes = 0;
    reassemble_agg.update(rpc_header.channel_id, new_agg);
    reassemble_buf.update(rpc_header.channel_id, new_buf);
    generate NET_SEND:net_send{ctx, old_buf};
  }
}
