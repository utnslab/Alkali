#Specify the functionality of the target archiecture

# Totoal 24 bytes
struct ip_header_t {
    # Version (4),  IHL (4), DSCP (6), ECN(2)
    bits<16> misc; 
    bits<16> length;
    bits<16> identification;
    # Flags (3), Fragment Offset (13)
    bits<16> fragment_offset;
    
    # TTL (8), Transport Protocol (8)
    bits<16> TTL_transport;
    bits<16> checksum;
    bits<32> source_ip;
    bits<32> dst_ip;
    bits<32> options;
}

struct dma_desc_t {
  bits<16> queue_id;
  bits<16> meta;
}

extern event NET_RECV {context ctx; buf packet;}
extern event NET_SEND {context ctx; buf packet;}
extern handler NET_SEND:net_send (context ctx, buf packet) { }


##############main program########## #

struct eth_header_t {
  bits<48> dst_mac;
  bits<48> src_mac;
  bits<16> ether_type;
}

#Totoal 8 bytes
struct udp_header_t {
    bits<16> sport;                    
    bits<16> dport;                    

    bits<16> len;                      
    bits<16> sum;                      
}

struct rpc_header_t {
  bits<32> channel_id;
  bits<32> seq;
  bits<32> seg_size;
  bits<32> total_size;
}

extern event MSG_REASSEMBLE {
  context ctx;
  buf packet;
  rpc_header_t rpc;
}

handler NET_RECV:process_packet(context ctx, buf packet) {
  eth_header_t eth_header;
  ip_header_t ip_header;
  udp_header_t udp_header_t;
  rpc_header_t rpc_header;

  packet.extract(eth_header);
  packet.extract(ip_header);
  packet.extract(udp_header_t);
  packet.extract(rpc_header);

  ctx.eth_header = eth_header;
  ctx.ip_header = ip_header;

  generate MSG_REASSEMBLE:msg_reassemble{ctx, packet, rpc_header};
}

struct agg_buf_t {
  bits<32> rest_bytes;
  bits<32> next_seq;
  buf tmp_buf;
}

handler MSG_REASSEMBLE:msg_reassemble(context ctx, buf data, rpc_header_t rpc_header) {
  table <bits<16>, agg_buf_t, 16> buf_reassemble;
  agg_buf_t agg_buf;
  # here do we init the buffer? check the generated code (for __buf_init)
  agg_buf_t new_buf;

  agg_buf = buf_reassemble.lookup(rpc_header.channel_id); 
  if(agg_buf.rest_bytes == 0){
    agg_buf.rest_bytes = rpc_header.total_size;
  }

  if(agg_buf.next_seq + 1 == rpc_header.seq){
    agg_buf.next_seq = agg_buf.next_seq + 1;
    agg_buf.tmp_buf.emit(data);
    agg_buf.rest_bytes = agg_buf.rest_bytes - rpc_header.seg_size;
  }

  if(agg_buf.rest_bytes > 0){
    buf_reassemble.update(rpc_header.channel_id, agg_buf);
  }
  else{
    # assume aligned case
    new_buf.rest_bytes = 0;
    buf_reassemble.update(rpc_header.channel_id, new_buf);

    generate NET_SEND:net_send{ctx, agg_buf.tmp_buf};
  }
}