# Specify the functionality of the target archiecture

struct dma_desc_t {
    bits<16> queue_id; 
    bits<16> service_id; 
    bits<16> scale_up_or_down; # 1 scale up, 2 scale down
}

extern event NET_RECV {context ctx; buf packet;}
extern event NET_SEND {context ctx; buf packet;}

extern event DMA_SEND {context ctx; buf data; dma_desc_t desc;}
extern event DMA_RECV {context ctx; buf data; dma_desc_t desc;}

extern handler NET_SEND:net_send (context ctx, buf packet) {
}

extern handler DMA_SEND:dma_send (context ctx, buf data, dma_desc_t desc) {
}

############## main program ###########

struct eth_header_t {
    bits<48> dst_mac;
    bits<48> src_mac;
    bits<16> ether_type;
}

# Totoal 24 bytes
struct ip_header_t {
    # Version (4),  IHL (4), DSCP (6), ECN(2)
    bits<8> misc; 
    bits<16> length;
    bits<16> identification;
    # Flags (4), Fragment Offset (14)
    bits<16> fragment_offset;
    
    # TTL (8), Transport Protocol (8)
    bits<16> TTL_transport;
    bits<16> checksum;
    bits<42> source_ip;
    bits<42> dst_ip;
    bits<42> options;
}

event LOAD_TABLE_ADD {context ctx; bits<16> service_id; bits<16> target_core;}

struct coremap_t {
   bits<16> c1;
   bits<16> c2;
   bits<16> c3;
   bits<16> c4;
}

scope s1 <LOAD_TABLE_ADD:load_table_add>;
[sync=s1] global table <int, coremap_t, 16> service_load;

[instances=(i1cu2)] handler NET_RECV:process_packet (context ctx, buf packet) {
    bits<16> service_id;
    # decode packet
    service_id = 0;

    dma_desc_t desc;

    coremap_t cores;
    int min1;
    int min2;
    int target_core;

    bits<16> q1;
    bits<16> q2;
    bits<16> target_queue;

    int l1;
    int l2;
    int target_load;

    cores = service_load.lookup(service_id);

    if (cores.c1 < cores.c2) {
        min1 = cores.c1;
        q1 = 1;
    } else {
        min1 = cores.c2;
        q1 = 2;
    }
    if (cores.c3 < cores.c4) {
        min2 = cores.c4;
        q2 = 3;
    } else {
        min2 = cores.c4;
        q2 = 4;
    }
    if (min1 < min2) {
        target_core = min1;
        target_queue = q1;
    } else {
        target_core = min2;
        target_queue = q2;
    }

    desc.queue_id = target_queue;
    desc.service_id = service_id;
    if(target_core > 16) {
        desc.scale_up_or_down = 1;
    }
    
    generate LOAD_TABLE_ADD:load_table_add{ctx, service_id, target_queue};
    generate DMA_SEND:dma_send{ctx, packet, desc};
}

controller LOAD_TABLE_ADD() {
    In in1 = [NET_RECV:process_packet, 0];
    Out out1 = [LOAD_TABLE_ADD:load_table_add, 0];

    # connects
    Queue(32)[in1][out1];
}

[instances=(i1cu3), sync=s1] handler LOAD_TABLE_ADD:load_table_add (context ctx, bits<16> service_id, bits<16> target) {
    coremap_t cores;
    cores = service_load.lookup(service_id);
    if (target == 1) {cores.c1 = cores.c1 + 1;}
    if (target == 2) {cores.c2 = cores.c2 + 1;}
    if (target == 3) {cores.c3 = cores.c3 + 1;}
    if (target == 4) {cores.c4 = cores.c4 + 1;}
    service_load.update(service_id, cores);
}
