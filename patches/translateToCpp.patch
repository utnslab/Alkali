diff --git a/mlir/lib/Target/Cpp/TranslateToCpp.cpp b/mlir/lib/Target/Cpp/TranslateToCpp.cpp
index 4645ca4b206e..9009ec4faedb 100644
--- a/mlir/lib/Target/Cpp/TranslateToCpp.cpp
+++ b/mlir/lib/Target/Cpp/TranslateToCpp.cpp
@@ -24,6 +24,7 @@
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/FormatVariadic.h"
 #include <utility>
+#include <cctype>
 
 #define DEBUG_TYPE "translate-to-cpp"
 
@@ -417,9 +418,197 @@ static LogicalResult printOperation(CppEmitter &emitter, emitc::CallOp callOp) {
   raw_ostream &os = emitter.ostream();
   Operation &op = *callOp.getOperation();
 
-  if (failed(emitter.emitAssignPrefix(op)))
-    return failure();
-  os << callOp.getCallee();
+  if (callOp.getCallee() != "__ep2_intrin_struct_write") {
+    if (failed(emitter.emitAssignPrefix(op)))
+      return failure();
+  }
+
+  if (callOp.getCallee() == "__ep2_intrin_struct_access") {
+    os << ((*callOp.getArgs()).size() > 1 && (*callOp.getArgs())[1].cast<IntegerAttr>().getValue().getSExtValue() ? "&" : "");
+    os << emitter.getOrCreateName(op.getOperand(0)) << "->";
+    if (isa<IntegerAttr>((*callOp.getArgs())[0])) {
+      os << "f" << (*callOp.getArgs())[0].cast<IntegerAttr>().getValue();
+    } else {
+      os << (*callOp.getArgs())[0].cast<StringAttr>().getValue();
+    }
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_struct_write") {
+    os << emitter.getOrCreateName(op.getOperand(1)) << "->";
+    if (isa<IntegerAttr>((*callOp.getArgs())[0])) {
+      os << "f" << (*callOp.getArgs())[0].cast<IntegerAttr>().getValue();
+    } else {
+      os << (*callOp.getArgs())[0].cast<StringAttr>().getValue();
+    }
+    os << " = ";
+    os << ((*callOp.getArgs()).size() > 1 && (*callOp.getArgs())[1].cast<IntegerAttr>().getValue().getSExtValue() ? "*" : "");
+    os << emitter.getOrCreateName(op.getOperand(0));
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_ctx_write") {
+    os << emitter.getOrCreateName(op.getOperand(1)) << "->";
+    if (isa<IntegerAttr>((*callOp.getArgs())[0])) {
+      os << "f" << (*callOp.getArgs())[0].cast<IntegerAttr>().getValue();
+    } else {
+      os << (*callOp.getArgs())[0].cast<StringAttr>().getValue();
+    }
+    os << " = ";
+    // support an embedded struct access.
+    if ((*callOp.getArgs()).size() >= 3 && (*callOp.getArgs())[2].cast<IntegerAttr>().getValue().getSExtValue()) {
+      os << emitter.getOrCreateName(op.getOperand(0)) << "->f";
+      os << (*callOp.getArgs())[0].cast<IntegerAttr>().getValue();
+    } else {
+      os << ((*callOp.getArgs()).size() > 1 && (*callOp.getArgs())[1].cast<IntegerAttr>().getValue().getSExtValue() ? "*" : "");
+      os << emitter.getOrCreateName(op.getOperand(0));
+    }
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_incr_ptr") {
+    os << emitter.getOrCreateName(op.getOperand(0)) << " += ";
+    os << (*callOp.getArgs())[0].cast<IntegerAttr>().getValue();
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_ctx_read") {
+    os << ((*callOp.getArgs())[1].cast<IntegerAttr>().getValue().getSExtValue() ? "&" : "");
+    os << emitter.getOrCreateName(op.getOperand(0)) << "->";
+    if (isa<IntegerAttr>((*callOp.getArgs())[0])) {
+      os << "f" << (*callOp.getArgs())[0].cast<IntegerAttr>().getValue();
+    } else {
+      os << (*callOp.getArgs())[0].cast<StringAttr>().getValue();
+    }
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_pkt_size_set") {
+    // TODO should choose between f0.offs vs f0.sz, depending on zero-copy buffer
+    os << "next_work_NET_SEND.meta.len = next_work_NET_SEND.f0.sz";
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_table_lookup") {
+    if ((*callOp.getArgs())[0].cast<IntegerAttr>().getValue().getSExtValue()) {
+      os << "*" << emitter.getOrCreateName(op.getOperand(2)) << " = ";
+    }
+    os << emitter.getOrCreateName(op.getOperand(0)) << "->table[";
+    os << "me_cam_lookup(" << emitter.getOrCreateName(op.getOperand(1)) << ")]";
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_table_update") {
+    os << emitter.getOrCreateName(op.getOperand(0)) << "->table[";
+    os << "me_cam_update(" << emitter.getOrCreateName(op.getOperand(1)) << ")]";
+    os << " = ";
+    os << ((*callOp.getArgs())[0].cast<IntegerAttr>().getValue().getSExtValue() ? "*" : "");
+    os << emitter.getOrCreateName(op.getOperand(2));
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_ternary") {
+    os << "(" << emitter.getOrCreateName(op.getOperand(0)) << " ? ";
+    os << emitter.getOrCreateName(op.getOperand(1)) << " : ";
+    os << emitter.getOrCreateName(op.getOperand(2)) << ")";
+    return success();
+  } else if (callOp.getCallee().starts_with("__ep2_intrin_memcpy_") || 
+             callOp.getCallee().starts_with("__ep2_intrin_memcpybuf_")) {
+
+    bool notBufCopy = callOp.getCallee().starts_with("__ep2_intrin_memcpy_");
+
+    // extract real name
+    llvm::StringRef realCallee = callOp.getCallee().substr(notBufCopy ? 20 : 23);
+    os << realCallee << "(";
+    int xferOffset = (*callOp.getArgs())[0].cast<IntegerAttr>().getValue().getSExtValue();
+    int tag = (*callOp.getArgs())[2].cast<IntegerAttr>().getValue().getSExtValue();
+
+    if (xferOffset >= 0) {
+      // a pointer arithmetic
+      os << emitter.getOrCreateName(op.getOperand(0)) << ".buf + ";
+      if (tag == 2) {
+        os << emitter.getOrCreateName(op.getOperand(0)) << ".offs, ";
+      } else {
+        os << xferOffset << ", ";
+      }
+    } else {
+      xferOffset = ~xferOffset;
+      os << "&" << emitter.getOrCreateName(op.getOperand(0)) << "->f" << xferOffset << ", ";
+    }
+
+    if (notBufCopy) {
+      os << "&" << emitter.getOrCreateName(op.getOperand(1)) << "->f" << xferOffset << ", ";
+    } else {
+      os << emitter.getOrCreateName(op.getOperand(1)) << ".buf + ";
+      os << emitter.getOrCreateName(op.getOperand(1)) << ".offs, ";
+    }
+
+    int sz = (*callOp.getArgs())[1].cast<IntegerAttr>().getValue().getSExtValue();
+    if (tag != 2) {
+      os << sz;
+    } else {
+      os << emitter.getOrCreateName(op.getOperand(1)) << ".sz - " << emitter.getOrCreateName(op.getOperand(1)) << ".offs";
+    }
+    os << ")";
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_deq_work") {
+    auto event = (*callOp.getArgs())[0].cast<StringAttr>().getValue();
+    auto queueId = (*callOp.getArgs())[1].cast<StringAttr>().getValue();
+
+    os << "cls_workq_add_thread(WORKQ_ID_" << event;
+    if (queueId != "") {
+      os << "_" << queueId;
+    }
+    os << ", " << emitter.getOrCreateName(op.getOperand(0)) << ", ";
+    os << "sizeof(*" << emitter.getOrCreateName(op.getOperand(0)) << "))";
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_enq_work") {
+    auto event = (*callOp.getArgs())[0].cast<StringAttr>().getValue();
+    std::string queueList = (*callOp.getArgs())[1].cast<StringAttr>().getValue().str();
+    llvm::SmallVector<int> queues;
+    
+    auto parseDescription = [&](std::string info) {
+      unsigned p = 0;
+      while (p < info.size()) {
+        int v = 0;
+        while (p < info.size() && isdigit(info[p])) {
+          v *= 10;
+          v += (info[p] - '0');
+          p += 1;
+        }
+        queues.push_back(v);
+        while (p < info.size() && !isdigit(info[p])) {
+          p += 1;
+        }
+      }
+    };
+    parseDescription(queueList);
+
+    if (queues.size() <= 1) {
+      os << "cls_workq_add_work(WORKQ_ID_" << event;
+      if (queues.size() == 0) {
+        // TODO handle extern replication
+      } else {
+        os << "_" << queues[0];
+      }
+      os << ", " << emitter.getOrCreateName(op.getOperand(0)) << ", ";
+      os << "sizeof(*" << emitter.getOrCreateName(op.getOperand(0)) << "))";
+    } else {
+      os << callOp->getAttr("func").cast<mlir::StringAttr>().getValue().str() << "()";
+    }
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_xfer2gpr" ||
+             callOp.getCallee() == "__ep2_intrin_gpr2xfer") {
+    os << "*(" << emitter.getOrCreateName(op.getOperand(1)) << ") = *(";
+    os << emitter.getOrCreateName(op.getOperand(0)) << ")";
+    return success();
+  } else if (callOp.getCallee() == "__ep2_intrin_incr_offs") {
+    int sz = (*callOp.getArgs())[1].cast<IntegerAttr>().getValue().getSExtValue();
+    int tag = (*callOp.getArgs())[0].cast<IntegerAttr>().getValue().getSExtValue();
+    int setVal = (*callOp.getArgs())[2].cast<IntegerAttr>().getValue().getSExtValue();
+
+    os << emitter.getOrCreateName(op.getOperand(0)) << ".offs ";
+    if (setVal == -1) {
+      os << "+";
+    }
+    os << "= ";
+    if (setVal == -1) {
+      if (tag != 2) {
+        os << sz;
+      } else {
+        os << emitter.getOrCreateName(op.getOperand(1)) << ".sz - " << emitter.getOrCreateName(op.getOperand(1)) << ".offs";
+      }
+    } else {
+      os << setVal;
+    }
+    return success();
+  } else {
+    os << callOp.getCallee();
+  }
 
   auto emitArgs = [&](Attribute attr) -> LogicalResult {
     if (auto t = dyn_cast<IntegerAttr>(attr)) {
@@ -451,10 +640,15 @@ static LogicalResult printOperation(CppEmitter &emitter, emitc::CallOp callOp) {
 
   os << "(";
 
-  LogicalResult emittedArgs =
-      callOp.getArgs()
-          ? interleaveCommaWithError(*callOp.getArgs(), os, emitArgs)
-          : emitter.emitOperands(op);
+  if (callOp.getArgs()) {
+    if (failed(
+            interleaveCommaWithError(*callOp.getArgs(), os, emitArgs)))
+      return failure();
+    if (op.getNumOperands() != 0)
+      os << ", ";
+  }
+
+  LogicalResult emittedArgs = emitter.emitOperands(op);
   if (failed(emittedArgs))
     return failure();
   os << ")";
@@ -787,7 +981,7 @@ StringRef CppEmitter::getOrCreateName(Block &block) {
 bool CppEmitter::shouldMapToUnsigned(IntegerType::SignednessSemantics val) {
   switch (val) {
   case IntegerType::Signless:
-    return false;
+    return true;
   case IntegerType::Signed:
     return false;
   case IntegerType::Unsigned:
@@ -1046,10 +1240,11 @@ LogicalResult CppEmitter::emitType(Location loc, Type type) {
   if (auto iType = dyn_cast<IntegerType>(type)) {
     switch (iType.getWidth()) {
     case 1:
-      return (os << "bool"), success();
+      return (os << "char"), success();
     case 8:
     case 16:
     case 32:
+    case 48:
     case 64:
       if (shouldMapToUnsigned(iType.getSignedness()))
         return (os << "uint" << iType.getWidth() << "_t"), success();
